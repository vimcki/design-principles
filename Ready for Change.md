# Ready for Change

## Information

Quality of code that is easy to change in the future. It means that code is:

1. maintainable,
1. easy to understand,
1. easy to extend,
1. easy to refactor.

Focusing on this means that you try to minimise costs of future development and speed at which you can deliver new features.

This is the most important quality.

In [Pragmatic Programmer](https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/) book there its called ETC: Easy to Change.

In [Design Principles and Design Patterns](http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf) Uncle Bob writes that changeing requirements are the reason that software degrades. Symptoms of rotting design are connected to inability to change or problems while making changes. Symptoms mentioned are: rigidity, fragility, immobility, viscosity.

## Resources

- [Pragmatic Programmer](https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/)
- [Design Principles and Design Patterns](http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf)

#value

metadata=This page explores the essential quality of 'Ready for Change' in software development. It underscores the significance of maintainability, comprehensibility, extensibility, and easy refactoring in producing code that is adaptable to future modifications. Discussing the insights from industry thought leaders like Uncle Bob and references from the Pragmatic Programmer book, it delves into the consequences of neglecting this principle, such as code rot and reduced agility in delivering new features. A valuable read for anyone seeking to enhance their software design skills and future-proof their codebase.
